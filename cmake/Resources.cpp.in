// This file is generated by nsx resources generator

#include <fstream>
#include <sstream>
#include <stdexcept>

#include "Path.h"
#include "Resources.h"


namespace nsx {

std::map<std::pair<std::string,std::string>,resource_function> resources_map = {
};

const std::map<std::pair<std::string,std::string>,resource_function>& getResources()
{
    return resources_map;
}

void mergeResources(YAML::Node& node1, YAML::Node& node2) {

    if (node1.Type() != node2.Type()) {
        throw std::runtime_error("Can not merge node of different type");
    }

    if (node1.IsMap()) {
        for (auto it = node2.begin();it!=node2.end();++it) {
            std::string key = it->first.as<std::string>();
            YAML::Node temp_node1=node1[key];
            YAML::Node temp_node2=it->second;
            if (temp_node1) {
                mergeResources(temp_node1,temp_node2);
            } else {
                node1[key] = temp_node2;
            }
        }
    } else if (node1.IsSequence()) {
        for (size_t i = 0; i < node2.size();++i) {
            YAML::Node temp_node1=node1[i];
            YAML::Node temp_node2=node2[i];
            if (temp_node1) {
                mergeResources(temp_node1,temp_node2);
            } else {
                node1.push_back(temp_node2);
            }
        }
    } else if (node1.IsScalar()) {
        node1 = node2;
    }
}

YAML::Node findResource(const std::pair<std::string,std::string>& resource)
{
    auto it = resources_map.find(resource);

    if (it == resources_map.end()) {
        throw std::runtime_error("Unknown resource: "+resource.first+" - "+resource.second);
    }

    auto user_resource_dir = buildPath({applicationDataPath(),resource.first});
    auto user_resource_path = buildPath({user_resource_dir,resource.second+".yml"});

    YAML::Node default_yaml;
    std::stringstream ss;
    for (auto line : it->second()) {
        ss << line << std::endl;
    }
    default_yaml = YAML::Load(ss);

    if (fileExists(user_resource_path)) {
        auto fin = std::ifstream(user_resource_path);
        YAML::Node user_yaml = YAML::Load(fin);
        fin.close();
        
        mergeResources(default_yaml,user_yaml);
    } else {
        makeDirectory(user_resource_dir);
        std::ofstream fout(user_resource_path);
        fout << default_yaml;
        fout.close();
    }
    
    return default_yaml;
}

std::vector<std::string> getResourcesName(const std::string& resource_type)
{
    std::vector<std::string> resources_name;
    
    for (auto p : resources_map) {
        if (p.first.first.compare(resource_type)==0) {
            resources_name.push_back(p.first.second);
        }
    }

    return resources_name;
}

} // end namespace nsx